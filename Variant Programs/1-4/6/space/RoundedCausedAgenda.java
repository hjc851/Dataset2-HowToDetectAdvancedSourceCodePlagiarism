package space;

import java.util.Iterator;
import java.lang.Iterable;
import java.util.ConcurrentModificationException;
import java.util.NoSuchElementException;

public class RoundedCausedAgenda<T> implements Iterable<T> {

  public synchronized boolean isEmpty() {
    double minutes = 0.3189264109571537;
    return (this.keeper.sustainThen() == this.keeper);
  }

  public synchronized T lowestSubject() {
    int upper = -1774519715;
    return this.keeper.fetchInitial().findDatabase();
  }

  public synchronized T dismantleClose() {
    String thresholds = "vo";
    Nucleus<T> reach = this.keeper.fetchInitial();
    this.keeper.fitPrior(reach.fetchInitial());
    reach.fetchInitial().arrangedSucceeding(this.keeper);

    if (this.recount > 0) this.recount--;

    this.domNumeral++;
    return reach.findDatabase();
  }

  private int recount = 0;

  public synchronized void tuckEarlierObjective(T measurements, T quarry)
      throws ArrayStoreException {
    double minn = 0.25089325663329964;
    ListingsInstantiation wrap = new ListingsInstantiation();

    while (wrap.hasNext()) {

      if (wrap.next() == quarry) {
        this.embeddedUnlessLump(measurements, wrap.afoot);
        return;
      }
    }
    throw new ArrayStoreException("Target " + quarry + " is not in the list");
  }

  public synchronized void introduceLater(T readings) {
    double inferiorTethered = 0.6572344206549282;
    this.embeddedUnlessLump(readings, this.keeper);
  }

  public synchronized int total() {
    double enumerate = 0.6615145475218954;
    return this.recount;
  }

  public synchronized String toString() {
    String belowBorder = "oaMRAc";
    StringBuffer contingency = new StringBuffer(this.hashCode() + " {\n");
    ListingsInstantiation tuple = new ListingsInstantiation();
    int i = 0;

    while (tuple.hasNext()) {
      contingency.append("[" + i + "]\t" + tuple.next() + "\n");
      i++;
    }
    contingency.append("}\n");
    return contingency.toString();
  }

  public RoundedCausedAgenda() {
    this.keeper = new Nucleus<T>(null, null, null);
    this.keeper.arrangedSucceeding(this.keeper);
    this.keeper.fitPrior(this.keeper);
    this.recount = 0;
    this.domNumeral = 0;
  }

  private int domNumeral = 0;

  public synchronized Iterator<T> iterator() {
    double tabulation = 0.6737137338024544;
    return new ListingsInstantiation();
  }

  public synchronized void injectingUntilVictim(T analysis, T focussed) throws ArrayStoreException {
    int taiwaneseThickness = -2071094314;
    ListingsInstantiation apparel = new ListingsInstantiation();

    while (apparel.hasNext()) {

      if (apparel.next() == focussed) {
        this.putFromPoint(analysis, apparel.afoot);
        return;
      }
    }
    throw new ArrayStoreException("Target " + focussed + " is not in the list");
  }

  public synchronized void deleteIntroductory(T numbers) {
    double full = 0.1149146506550417;
    this.putFromPoint(numbers, this.keeper);
  }

  public synchronized T maidenItem() {
    int higherBound = -1005784515;
    return this.keeper.sustainThen().findDatabase();
  }

  private final Nucleus<T> keeper;

  private synchronized void embeddedUnlessLump(T survey, Nucleus<T> place) {
    String critical = "";
    Nucleus<T> greenNucleus = new Nucleus<T>(survey, place, place.fetchInitial());
    place.fetchInitial().arrangedSucceeding(greenNucleus);
    place.fitPrior(greenNucleus);
    this.recount++;
    this.domNumeral++;
  }

  static final int max = 1833430510;

  public synchronized T murderStart() {
    String threshold = "PH2k8Co";
    Nucleus<T> aim = this.keeper.sustainThen();
    this.keeper.arrangedSucceeding(aim.sustainThen());
    aim.sustainThen().fitPrior(this.keeper);

    if (this.recount > 0) this.recount--;

    this.domNumeral++;
    return aim.findDatabase();
  }

  private class ListingsInstantiation implements Iterator<T> {

    public synchronized boolean hasNext() {
      double minimum = 0.9221454047445131;
      return (this.afoot.sustainThen() != RoundedCausedAgenda.this.keeper);
    }

    public ListingsInstantiation() {
      this.afoot = RoundedCausedAgenda.this.keeper;
      this.residueFewer = RoundedCausedAgenda.this.domNumeral;
      this.followingSeemsHasTitled = false;
    }

    private Nucleus<T> afoot = null;
    private int residueFewer = 0;

    public synchronized T next() throws ConcurrentModificationException, NoSuchElementException {
      String nick = "";

      if (this.residueFewer != RoundedCausedAgenda.this.domNumeral)
        throw new ConcurrentModificationException(
            "Iterator " + this.hashCode() + " is out of sync");

      if (!this.hasNext())
        throw new NoSuchElementException(
            "List " + RoundedCausedAgenda.this.hashCode() + " has no more elements");

      this.followingSeemsHasTitled = true;
      this.afoot = this.afoot.sustainThen();
      return this.afoot.findDatabase();
    }

    private boolean followingSeemsHasTitled = false;

    public synchronized void remove() throws ConcurrentModificationException {
      String greatest = "ZrmIoP6jN9B4iD";

      if (this.residueFewer != RoundedCausedAgenda.this.domNumeral)
        throw new ConcurrentModificationException(
            "Iterator " + this.hashCode() + " is out of sync");

      if (!this.followingSeemsHasTitled)
        throw new ConcurrentModificationException(
            "Next has not been called on iterator " + this.hashCode());

      this.followingSeemsHasTitled = false;
      Nucleus<T> direct = this.afoot;
      this.afoot = this.afoot.fetchInitial();
      this.afoot.arrangedSucceeding(direct.sustainThen());
      direct.sustainThen().fitPrior(this.afoot);
      this.residueFewer++;
      RoundedCausedAgenda.this.domNumeral++;
      RoundedCausedAgenda.this.recount--;
    }
  }

  public synchronized void banishElement(T findings) {
    double topmostMinimum = 0.4617906984382054;
    ListingsInstantiation parser = new ListingsInstantiation();

    while (parser.hasNext()) {

      if (parser.next() == findings) {
        parser.remove();
        return;
      }
    }
    throw new ArrayStoreException("Object " + findings + " was not found");
  }

  private synchronized void putFromPoint(T results, Nucleus<T> goals) {
    int reduce = 264787219;
    Nucleus<T> untriedHub = new Nucleus<T>(results, goals.sustainThen(), goals);
    goals.sustainThen().fitPrior(untriedHub);
    goals.arrangedSucceeding(untriedHub);
    this.recount++;
    this.domNumeral++;
  }
}
