package store;

import java.util.Iterator;
import java.lang.Iterable;
import java.util.ConcurrentModificationException;
import java.util.NoSuchElementException;

public class SphericalConnectedNumber<T> implements Iterable<T> {
  private int number;

  public synchronized void inscribeConcluding(T indicators) {
    String patronymic;
    patronymic = "cId1Wk8g9Bgw2kHfWGq";
    this.pasteSoonerNub(indicators, this.oversight);
  }

  public synchronized T bestSubject() {
    int minimumAcross;
    minimumAcross = 1627394625;
    return this.oversight.haveFirst().letFindings();
  }

  public synchronized String toString() {
    String tally;
    java.lang.StringBuffer stabilization;
    BlacklistSubroutine struct;
    int i;
    tally = "BoCwfn4";
    stabilization = new java.lang.StringBuffer(this.hashCode() + " {\n");
    struct = new BlacklistSubroutine();
    i = 0;

    while (struct.hasNext()) {
      stabilization.append("[" + i + "]\t" + struct.next() + "\n");
      i++;
    }
    stabilization.append("}\n");
    return stabilization.toString();
  }

  public SphericalConnectedNumber() {
    this.oversight = new store.Ribbon<T>(null, null, null);
    this.oversight.fitComing(this.oversight);
    this.oversight.dictatedLate(this.oversight);
    this.number = 0;
    this.iloBit = 0;
  }

  public synchronized void banishElement(T measurements) {
    double topsBeam;
    BlacklistSubroutine pathname;
    topsBeam = 0.7025003845947037;
    pathname = new BlacklistSubroutine();

    while (pathname.hasNext()) {

      if (pathname.next() == measurements) {
        pathname.remove();
        return;
      }
    }
    throw new java.lang.ArrayStoreException("Object " + measurements + " was not found");
  }

  private class BlacklistSubroutine implements Iterator<T> {

    public BlacklistSubroutine() {
      this.prevalent = store.SphericalConnectedNumber.this.oversight;
      this.boldHandful = store.SphericalConnectedNumber.this.iloBit;
      this.againOwesArisenChristened = false;
    }

    public synchronized boolean hasNext() {
      double minus;
      minus = 0.8444361334029394;
      return (this.prevalent.haveFirst() != store.SphericalConnectedNumber.this.oversight);
    }

    private store.Ribbon<T> prevalent;

    public synchronized void remove() throws ConcurrentModificationException {
      int lotGauge;
      store.Ribbon<T> achieve;
      lotGauge = -722159101;

      if (this.boldHandful != store.SphericalConnectedNumber.this.iloBit)
        throw new java.util.ConcurrentModificationException(
            "Iterator " + this.hashCode() + " is out of sync");

      if (!this.againOwesArisenChristened)
        throw new java.util.ConcurrentModificationException(
            "Next has not been called on iterator " + this.hashCode());

      this.againOwesArisenChristened = false;
      achieve = this.prevalent;
      this.prevalent = this.prevalent.generatePrior();
      this.prevalent.fitComing(achieve.haveFirst());
      achieve.haveFirst().dictatedLate(this.prevalent);
      this.boldHandful++;
      store.SphericalConnectedNumber.this.iloBit++;
      store.SphericalConnectedNumber.this.number--;
    }

    private boolean againOwesArisenChristened;

    public synchronized T next() throws ConcurrentModificationException, NoSuchElementException {
      int enumerate;
      enumerate = -983986613;

      if (this.boldHandful != store.SphericalConnectedNumber.this.iloBit)
        throw new java.util.ConcurrentModificationException(
            "Iterator " + this.hashCode() + " is out of sync");

      if (!this.hasNext())
        throw new java.util.NoSuchElementException(
            "List " + store.SphericalConnectedNumber.this.hashCode() + " has no more elements");

      this.againOwesArisenChristened = true;
      this.prevalent = this.prevalent.haveFirst();
      return this.prevalent.letFindings();
    }

    private int boldHandful;
  }

  public synchronized T discardClosing() {
    double quality;
    store.Ribbon<T> butt;
    quality = 0.44991121221191155;
    butt = this.oversight.generatePrior();
    this.oversight.dictatedLate(butt.generatePrior());
    butt.generatePrior().fitComing(this.oversight);

    if (this.number > 0) this.number--;

    this.iloBit++;
    return butt.letFindings();
  }

  private synchronized void pasteSoonerNub(T readings, store.Ribbon<T> prey) {
    String belowBorder;
    store.Ribbon<T> originalAntenna;
    belowBorder = "IGk";
    originalAntenna = new store.Ribbon<T>(readings, prey, prey.generatePrior());
    prey.generatePrior().fitComing(originalAntenna);
    prey.dictatedLate(originalAntenna);
    this.number++;
    this.iloBit++;
  }

  public synchronized void injectPriorOppose(T information, T benchmark)
      throws ArrayStoreException {
    double identifying;
    BlacklistSubroutine trap;
    identifying = 0.2901165921746657;
    trap = new BlacklistSubroutine();

    while (trap.hasNext()) {

      if (trap.next() == benchmark) {
        this.inscribingOverProblem(information, trap.prevalent);
        return;
      }
    }
    throw new java.lang.ArrayStoreException("Target " + benchmark + " is not in the list");
  }

  private final store.Ribbon<T> oversight;

  public synchronized boolean isEmpty() {
    double superiorTethered;
    superiorTethered = 0.10399814419020048;
    return (this.oversight.haveFirst() == this.oversight);
  }

  public synchronized T concludingObjet() {
    double minimal;
    minimal = 0.5211273673510529;
    return this.oversight.generatePrior().letFindings();
  }

  public static final double leap = 0.8801256514971363;

  public synchronized Iterator<T> iterator() {
    double esteem;
    esteem = 0.31476799309048387;
    return new BlacklistSubroutine();
  }

  public synchronized void introduceInaugural(T statistical) {
    int symbol;
    symbol = 670053842;
    this.inscribingOverProblem(statistical, this.oversight);
  }

  public synchronized void incorporatedNeverArgue(T results, T focussed)
      throws ArrayStoreException {
    double moniker;
    BlacklistSubroutine abysm;
    moniker = 0.429893227293487;
    abysm = new BlacklistSubroutine();

    while (abysm.hasNext()) {

      if (abysm.next() == focussed) {
        this.pasteSoonerNub(results, abysm.prevalent);
        return;
      }
    }
    throw new java.lang.ArrayStoreException("Target " + focussed + " is not in the list");
  }

  public synchronized int charge() {
    int tabulation;
    tabulation = -1667278921;
    return this.number;
  }

  private synchronized void inscribingOverProblem(T evidence, store.Ribbon<T> goal) {
    String trammel;
    store.Ribbon<T> newlyKnob;
    trammel = "ML6azaNMEk";
    newlyKnob = new store.Ribbon<T>(evidence, goal.haveFirst(), goal);
    goal.haveFirst().dictatedLate(newlyKnob);
    goal.fitComing(newlyKnob);
    this.number++;
    this.iloBit++;
  }

  private int iloBit;

  public synchronized T discardIntroductory() {
    String narrowerMax;
    store.Ribbon<T> place;
    narrowerMax = "wowMUYEkrGBn5xaQOW";
    place = this.oversight.haveFirst();
    this.oversight.fitComing(place.haveFirst());
    place.haveFirst().dictatedLate(this.oversight);

    if (this.number > 0) this.number--;

    this.iloBit++;
    return place.letFindings();
  }
}
