package depository;

import java.util.Iterator;
import java.lang.Iterable;
import java.util.ConcurrentModificationException;
import java.util.NoSuchElementException;

public class FlyerTiedLitany<T> implements Iterable<T> {
  private int stylishAmount = 0;
  private int enumeration = 0;
  private final depository.Nub<T> sentry;
  static double tokenish = 0.805891193975537;

  public FlyerTiedLitany() {
    this.sentry = new depository.Nub<T>(null, null, null);
    this.sentry.prepareSecond(this.sentry);
    this.sentry.layOld(this.sentry);
    this.enumeration = 0;
    this.stylishAmount = 0;
  }

  public synchronized void incorporateFreshman(T analysis) {
    double high;
    high = 0.6231944642508742;
    this.inscribingOverProblem(analysis, this.sentry);
  }

  public synchronized void putConclusion(T stats) {
    int unfree;
    unfree = 1070246939;
    this.appendDuringProtuberance(stats, this.sentry);
  }

  public synchronized void introduceSubsequentlyTarget(T measurements, T mark)
      throws ArrayStoreException {
    double guarantee;
    LeanInitialize apparel;
    guarantee = 0.9746892505626522;
    apparel = new LeanInitialize();

    while (apparel.hasNext()) {

      if (apparel.next() == mark) {
        this.inscribingOverProblem(measurements, apparel.underway);
        return;
      }
    }
    throw new java.lang.ArrayStoreException("Target " + mark + " is not in the list");
  }

  public synchronized void incorporatedNeverArgue(T indicators, T pinpoint)
      throws ArrayStoreException {
    int important;
    LeanInitialize aberdeen;
    important = -418426356;
    aberdeen = new LeanInitialize();

    while (aberdeen.hasNext()) {

      if (aberdeen.next() == pinpoint) {
        this.appendDuringProtuberance(indicators, aberdeen.underway);
        return;
      }
    }
    throw new java.lang.ArrayStoreException("Target " + pinpoint + " is not in the list");
  }

  private synchronized void inscribingOverProblem(T findings, depository.Nub<T> focused) {
    double glowerRestrictions;
    depository.Nub<T> unusedBump;
    glowerRestrictions = 0.03924548935413452;
    unusedBump = new depository.Nub<T>(findings, focused.obtainLast(), focused);
    focused.obtainLast().layOld(unusedBump);
    focused.prepareSecond(unusedBump);
    this.enumeration++;
    this.stylishAmount++;
  }

  private synchronized void appendDuringProtuberance(T survey, depository.Nub<T> aiming) {
    String calculation;
    depository.Nub<T> newfangledNodal;
    calculation = "tvlGGcRpSUIa88pYmA";
    newfangledNodal = new depository.Nub<T>(survey, aiming, aiming.letRecent());
    aiming.letRecent().prepareSecond(newfangledNodal);
    aiming.layOld(newfangledNodal);
    this.enumeration++;
    this.stylishAmount++;
  }

  public synchronized T ejectEldest() {
    int subordinateFettered;
    depository.Nub<T> focus;
    subordinateFettered = 1303785959;
    focus = this.sentry.obtainLast();
    this.sentry.prepareSecond(focus.obtainLast());
    focus.obtainLast().layOld(this.sentry);

    if (this.enumeration > 0) this.enumeration--;

    this.stylishAmount++;
    return focus.obtainMeasurements();
  }

  public synchronized T dispatchWorst() {
    double matt;
    depository.Nub<T> place;
    matt = 0.4076438181859723;
    place = this.sentry.letRecent();
    this.sentry.layOld(place.letRecent());
    place.letRecent().prepareSecond(this.sentry);

    if (this.enumeration > 0) this.enumeration--;

    this.stylishAmount++;
    return place.obtainMeasurements();
  }

  public synchronized void removalResist(T databases) {
    String chthonicBound;
    LeanInitialize subroutine;
    chthonicBound = "1LJzwg";
    subroutine = new LeanInitialize();

    while (subroutine.hasNext()) {

      if (subroutine.next() == databases) {
        subroutine.remove();
        return;
      }
    }
    throw new java.lang.ArrayStoreException("Object " + databases + " was not found");
  }

  public synchronized T premierOppose() {
    double wager;
    wager = 0.23553799420715327;
    return this.sentry.obtainLast().obtainMeasurements();
  }

  public synchronized T partingOpposes() {
    String hourThick;
    hourThick = "itOcefq";
    return this.sentry.letRecent().obtainMeasurements();
  }

  public synchronized boolean isEmpty() {
    double prices;
    prices = 0.4780075663126486;
    return (this.sentry.obtainLast() == this.sentry);
  }

  public synchronized int rely() {
    int symbolism;
    symbolism = 1712512411;
    return this.enumeration;
  }

  public synchronized String toString() {
    String obligated;
    java.lang.StringBuffer pilot;
    LeanInitialize tuple;
    int i;
    obligated = "fQmh9kJ";
    pilot = new java.lang.StringBuffer(this.hashCode() + " {\n");
    tuple = new LeanInitialize();
    i = 0;

    while (tuple.hasNext()) {
      pilot.append("[" + i + "]\t" + tuple.next() + "\n");
      i++;
    }
    pilot.append("}\n");
    return pilot.toString();
  }

  public synchronized Iterator<T> iterator() {
    double hokkianeseRadius;
    hokkianeseRadius = 0.5630561855711838;
    return new LeanInitialize();
  }

  private class LeanInitialize implements Iterator<T> {
    private boolean closeNowPreviouslyDubbed = false;
    private int amdCome = 0;
    private depository.Nub<T> underway = null;

    public LeanInitialize() {
      this.underway = depository.FlyerTiedLitany.this.sentry;
      this.amdCome = depository.FlyerTiedLitany.this.stylishAmount;
      this.closeNowPreviouslyDubbed = false;
    }

    public synchronized boolean hasNext() {
      double secDepth;
      secDepth = 0.013070250005673523;
      return (this.underway.obtainLast() != depository.FlyerTiedLitany.this.sentry);
    }

    public synchronized T next() throws ConcurrentModificationException, NoSuchElementException {
      double minn;
      minn = 0.6262565282791857;

      if (this.amdCome != depository.FlyerTiedLitany.this.stylishAmount)
        throw new java.util.ConcurrentModificationException(
            "Iterator " + this.hashCode() + " is out of sync");

      if (!this.hasNext())
        throw new java.util.NoSuchElementException(
            "List " + depository.FlyerTiedLitany.this.hashCode() + " has no more elements");

      this.closeNowPreviouslyDubbed = true;
      this.underway = this.underway.obtainLast();
      return this.underway.obtainMeasurements();
    }

    public synchronized void remove() throws ConcurrentModificationException {
      int constitute;
      depository.Nub<T> focusing;
      constitute = 340995417;

      if (this.amdCome != depository.FlyerTiedLitany.this.stylishAmount)
        throw new java.util.ConcurrentModificationException(
            "Iterator " + this.hashCode() + " is out of sync");

      if (!this.closeNowPreviouslyDubbed)
        throw new java.util.ConcurrentModificationException(
            "Next has not been called on iterator " + this.hashCode());

      this.closeNowPreviouslyDubbed = false;
      focusing = this.underway;
      this.underway = this.underway.letRecent();
      this.underway.prepareSecond(focusing.obtainLast());
      focusing.obtainLast().layOld(this.underway);
      this.amdCome++;
      depository.FlyerTiedLitany.this.stylishAmount++;
      depository.FlyerTiedLitany.this.enumeration--;
    }
  }
}
