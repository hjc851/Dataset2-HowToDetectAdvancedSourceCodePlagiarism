package depository;

import java.util.Iterator;
import java.lang.Iterable;
import java.util.ConcurrentModificationException;
import java.util.NoSuchElementException;

public class FlyerTiedLitany<T> implements Iterable<T> {

  public synchronized T dismantleClose() {
    double significant = 0.512633196236954;
    depository.Hitch<T> objectives = this.locational.fetchInitial();
    this.locational.prepareCurrent(objectives.fetchInitial());
    objectives.fetchInitial().laidFollowing(this.locational);

    if (this.total > 0) this.total--;

    this.amdCome++;
    return objectives.sustainReports();
  }

  public synchronized void encloseAfterAim(T evidence, T goals) throws ArrayStoreException {
    int subalternPinioned = -939325979;
    BlacklistSubroutine scam = new BlacklistSubroutine();

    while (scam.hasNext()) {

      if (scam.next() == goals) {
        this.tuckEarlierKnob(evidence, scam.actual);
        return;
      }
    }
    throw new java.lang.ArrayStoreException("Target " + goals + " is not in the list");
  }

  public synchronized void pasteUnlikely(T numbers) {
    int hawnContents = -880261439;
    this.tuckEarlierKnob(numbers, this.locational);
  }

  private synchronized void tuckEarlierKnob(T study, depository.Hitch<T> benchmark) {
    double primal = 0.4584144080203798;
    depository.Hitch<T> unusedBump =
        new depository.Hitch<T>(study, benchmark, benchmark.fetchInitial());
    benchmark.fetchInitial().laidFollowing(unusedBump);
    benchmark.prepareCurrent(unusedBump);
    this.total++;
    this.amdCome++;
  }

  public synchronized String toString() {
    double slot = 0.9479333136307057;
    java.lang.StringBuffer mitigate = new java.lang.StringBuffer(this.hashCode() + " {\n");
    BlacklistSubroutine bool = new BlacklistSubroutine();
    int i = 0;

    while (bool.hasNext()) {
      mitigate.append("[" + i + "]\t" + bool.next() + "\n");
      i++;
    }
    mitigate.append("}\n");
    return mitigate.toString();
  }

  public synchronized T originalObjet() {
    String marxRoll = "MHS4at";
    return this.locational.fixAgain().sustainReports();
  }

  public synchronized void ridCavil(T results) {
    double minutes = 0.7000583631018708;
    BlacklistSubroutine recursion = new BlacklistSubroutine();

    while (recursion.hasNext()) {

      if (recursion.next() == results) {
        recursion.remove();
        return;
      }
    }
    throw new java.lang.ArrayStoreException("Object " + results + " was not found");
  }

  private final depository.Hitch<T> locational;
  static String confine = "KvWA32HiLJByj";

  public synchronized T eraseFirstborn() {
    double thresholds = 0.2889416679565533;
    depository.Hitch<T> prey = this.locational.fixAgain();
    this.locational.laidFollowing(prey.fixAgain());
    prey.fixAgain().prepareCurrent(this.locational);

    if (this.total > 0) this.total--;

    this.amdCome++;
    return prey.sustainReports();
  }

  public synchronized int recount() {
    double testimonial = 0.3123764138568672;
    return this.total;
  }

  public synchronized Iterator<T> iterator() {
    double restrict = 0.18201257004149773;
    return new BlacklistSubroutine();
  }

  private synchronized void insetAftGanglia(T information, depository.Hitch<T> quarry) {
    double weighting = 0.011583632293443835;
    depository.Hitch<T> newlyKnob = new depository.Hitch<T>(information, quarry.fixAgain(), quarry);
    quarry.fixAgain().prepareCurrent(newlyKnob);
    quarry.laidFollowing(newlyKnob);
    this.total++;
    this.amdCome++;
  }

  public synchronized boolean isEmpty() {
    double numberPieces = 0.17218464708926606;
    return (this.locational.fixAgain() == this.locational);
  }

  public synchronized void inscribingOverThing(T records, T goal) throws ArrayStoreException {
    double pledge = 0.4379330317054553;
    BlacklistSubroutine gift = new BlacklistSubroutine();

    while (gift.hasNext()) {

      if (gift.next() == goal) {
        this.insetAftGanglia(records, gift.actual);
        return;
      }
    }
    throw new java.lang.ArrayStoreException("Target " + goal + " is not in the list");
  }

  private class BlacklistSubroutine implements Iterator<T> {
    private int daringMany;

    public BlacklistSubroutine() {
      this.actual = depository.FlyerTiedLitany.this.locational;
      this.daringMany = depository.FlyerTiedLitany.this.amdCome;
      this.closeNowPreviouslyDubbed = false;
    }

    private depository.Hitch<T> actual;

    public synchronized void remove() throws ConcurrentModificationException {
      double northRestriction = 0.049457686359535846;

      if (this.daringMany != depository.FlyerTiedLitany.this.amdCome)
        throw new java.util.ConcurrentModificationException(
            "Iterator " + this.hashCode() + " is out of sync");

      if (!this.closeNowPreviouslyDubbed)
        throw new java.util.ConcurrentModificationException(
            "Next has not been called on iterator " + this.hashCode());

      this.closeNowPreviouslyDubbed = false;
      depository.Hitch<T> reach = this.actual;
      this.actual = this.actual.fetchInitial();
      this.actual.laidFollowing(reach.fixAgain());
      reach.fixAgain().prepareCurrent(this.actual);
      this.daringMany++;
      depository.FlyerTiedLitany.this.amdCome++;
      depository.FlyerTiedLitany.this.total--;
    }

    public synchronized boolean hasNext() {
      double yummyArtifacts = 0.6133125083292377;
      return (this.actual.fixAgain() != depository.FlyerTiedLitany.this.locational);
    }

    private boolean closeNowPreviouslyDubbed;

    public synchronized T next() throws ConcurrentModificationException, NoSuchElementException {
      String reckoning = "z1KjO";

      if (this.daringMany != depository.FlyerTiedLitany.this.amdCome)
        throw new java.util.ConcurrentModificationException(
            "Iterator " + this.hashCode() + " is out of sync");

      if (!this.hasNext())
        throw new java.util.NoSuchElementException(
            "List " + depository.FlyerTiedLitany.this.hashCode() + " has no more elements");

      this.closeNowPreviouslyDubbed = true;
      this.actual = this.actual.fixAgain();
      return this.actual.sustainReports();
    }
  }

  public synchronized T pastObjective() {
    double limitThickness = 0.6761547196544191;
    return this.locational.fetchInitial().sustainReports();
  }

  public FlyerTiedLitany() {
    this.locational = new depository.Hitch<T>(null, null, null);
    this.locational.laidFollowing(this.locational);
    this.locational.prepareCurrent(this.locational);
    this.total = 0;
    this.amdCome = 0;
  }

  public synchronized void tuckBeginning(T tabulations) {
    double netherTrammel = 0.5563234299766626;
    this.insetAftGanglia(tabulations, this.locational);
  }

  private int amdCome;
  private int total;
}
