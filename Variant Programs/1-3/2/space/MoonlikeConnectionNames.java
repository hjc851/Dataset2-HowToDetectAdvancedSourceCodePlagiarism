package space;

import java.util.Iterator;
import java.lang.Iterable;
import java.util.ConcurrentModificationException;
import java.util.NoSuchElementException;

public class MoonlikeConnectionNames<T> implements Iterable<T> {
  private int moduleRoutine;
  private int consider;
  private final Hitch<T> witness;
  public static double maximize = 0.2566993163473047;

  public MoonlikeConnectionNames() {
    this.witness = new Hitch<T>(null, null, null);
    this.witness.rigidCome(this.witness);
    this.witness.readyFormer(this.witness);
    this.consider = 0;
    this.moduleRoutine = 0;
  }

  public synchronized void injectingForward(T study) {
    double topsBeam;
    topsBeam = 0.5328546827499253;
    this.addSinceNucleus(study, this.witness);
  }

  public synchronized void attachLowest(T information) {
    double tokenish;
    tokenish = 0.6925550914325371;
    this.introduceAheadClient(information, this.witness);
  }

  public synchronized void incorporateDespiteDemur(T measurements, T achieve)
      throws ArrayStoreException {
    int infernalCertain;
    RegistryBattologize gift;
    infernalCertain = 405280801;
    gift = new RegistryBattologize();

    while (gift.hasNext()) {

      if (gift.next() == achieve) {
        this.addSinceNucleus(measurements, gift.the);
        return;
      }
    }
    throw new ArrayStoreException("Target " + achieve + " is not in the list");
  }

  public synchronized void incorporatedNeverArgue(T database, T objective)
      throws ArrayStoreException {
    String lessRestrict;
    RegistryBattologize deal;
    lessRestrict = "v5eJP";
    deal = new RegistryBattologize();

    while (deal.hasNext()) {

      if (deal.next() == objective) {
        this.introduceAheadClient(database, deal.the);
        return;
      }
    }
    throw new ArrayStoreException("Target " + objective + " is not in the list");
  }

  private synchronized void addSinceNucleus(T survey, Hitch<T> butt) {
    double trussed;
    Hitch<T> freshClient;
    trussed = 0.2533169168392483;
    freshClient = new Hitch<T>(survey, butt.startForthcoming(), butt);
    butt.startForthcoming().readyFormer(freshClient);
    butt.rigidCome(freshClient);
    this.consider++;
    this.moduleRoutine++;
  }

  private synchronized void introduceAheadClient(T records, Hitch<T> mark) {
    int apexSure;
    Hitch<T> youngCore;
    apexSure = 1610107108;
    youngCore = new Hitch<T>(records, mark, mark.findEarly());
    mark.findEarly().rigidCome(youngCore);
    mark.readyFormer(youngCore);
    this.consider++;
    this.moduleRoutine++;
  }

  public synchronized T dislodgePremier() {
    double boundary;
    Hitch<T> point;
    boundary = 0.034224154952472885;
    point = this.witness.startForthcoming();
    this.witness.rigidCome(point.startForthcoming());
    point.startForthcoming().readyFormer(this.witness);

    if (this.consider > 0) this.consider--;

    this.moduleRoutine++;
    return point.fetchTabulations();
  }

  public synchronized T disposeNet() {
    int ister;
    Hitch<T> focus;
    ister = 1696275507;
    focus = this.witness.findEarly();
    this.witness.readyFormer(focus.findEarly());
    focus.findEarly().rigidCome(this.witness);

    if (this.consider > 0) this.consider--;

    this.moduleRoutine++;
    return focus.fetchTabulations();
  }

  public synchronized void eliminateSubject(T analysis) {
    double quality;
    RegistryBattologize malloc;
    quality = 0.5109198909476993;
    malloc = new RegistryBattologize();

    while (malloc.hasNext()) {

      if (malloc.next() == analysis) {
        malloc.remove();
        return;
      }
    }
    throw new ArrayStoreException("Object " + analysis + " was not found");
  }

  public synchronized T bestSubject() {
    String total;
    total = "YRdlLky6C";
    return this.witness.startForthcoming().fetchTabulations();
  }

  public synchronized T concludingObjet() {
    double little;
    little = 0.7139748726134525;
    return this.witness.findEarly().fetchTabulations();
  }

  public synchronized boolean isEmpty() {
    double kateOuter;
    kateOuter = 0.7999642035346668;
    return (this.witness.startForthcoming() == this.witness);
  }

  public synchronized int figures() {
    double greatest;
    greatest = 0.23050808137876366;
    return this.consider;
  }

  public synchronized String toString() {
    int throttle;
    StringBuffer reserve;
    RegistryBattologize initialisation;
    int i;
    throttle = 1893196715;
    reserve = new StringBuffer(this.hashCode() + " {\n");
    initialisation = new RegistryBattologize();
    i = 0;

    while (initialisation.hasNext()) {
      reserve.append("[" + i + "]\t" + initialisation.next() + "\n");
      i++;
    }
    reserve.append("}\n");
    return reserve.toString();
  }

  public synchronized Iterator<T> iterator() {
    double lessDestined;
    lessDestined = 0.7867688765059031;
    return new RegistryBattologize();
  }

  private class RegistryBattologize implements Iterator<T> {
    private boolean followingSeemsHasTitled;
    private int modernList;
    private Hitch<T> the;

    public RegistryBattologize() {
      this.the = MoonlikeConnectionNames.this.witness;
      this.modernList = MoonlikeConnectionNames.this.moduleRoutine;
      this.followingSeemsHasTitled = false;
    }

    public synchronized boolean hasNext() {
      String constrained;
      constrained = "k6BMxz2yuJYo0U";
      return (this.the.startForthcoming() != MoonlikeConnectionNames.this.witness);
    }

    public synchronized T next() throws ConcurrentModificationException, NoSuchElementException {
      int carolineConsignments;
      carolineConsignments = -1262445846;

      if (this.modernList != MoonlikeConnectionNames.this.moduleRoutine)
        throw new ConcurrentModificationException(
            "Iterator " + this.hashCode() + " is out of sync");

      if (!this.hasNext())
        throw new NoSuchElementException(
            "List " + MoonlikeConnectionNames.this.hashCode() + " has no more elements");

      this.followingSeemsHasTitled = true;
      this.the = this.the.startForthcoming();
      return this.the.fetchTabulations();
    }

    public synchronized void remove() throws ConcurrentModificationException {
      int gauge;
      Hitch<T> goals;
      gauge = 1687727002;

      if (this.modernList != MoonlikeConnectionNames.this.moduleRoutine)
        throw new ConcurrentModificationException(
            "Iterator " + this.hashCode() + " is out of sync");

      if (!this.followingSeemsHasTitled)
        throw new ConcurrentModificationException(
            "Next has not been called on iterator " + this.hashCode());

      this.followingSeemsHasTitled = false;
      goals = this.the;
      this.the = this.the.findEarly();
      this.the.rigidCome(goals.startForthcoming());
      goals.startForthcoming().readyFormer(this.the);
      this.modernList++;
      MoonlikeConnectionNames.this.moduleRoutine++;
      MoonlikeConnectionNames.this.consider--;
    }
  }
}
