package storehouse;

import java.util.Iterator;
import java.lang.Iterable;
import java.util.ConcurrentModificationException;
import java.util.NoSuchElementException;

public class DiscoidInvolvedCompendium<T> implements Iterable<T> {
  private int boldlyCaseload;
  private int weigh;
  private final storehouse.Scn<T> locational;
  public static final int diagnose = -454583013;

  public DiscoidInvolvedCompendium() {
    this.locational = new storehouse.Scn<T>(null, null, null);
    this.locational.situatedForthcoming(this.locational);
    this.locational.determineInitial(this.locational);
    this.weigh = 0;
    this.boldlyCaseload = 0;
  }

  public synchronized void incorporatedFirstborn(T readings) {
    double topShackled;
    topShackled = 0.6095073633351666;
    this.deleteThenEntanglement(readings, this.locational);
  }

  public synchronized void installSenior(T numbers) {
    double chained;
    chained = 0.9772584350856317;
    this.introduceAheadClient(numbers, this.locational);
  }

  public synchronized void integrateWithinDisagree(T results, T focusing)
      throws ArrayStoreException {
    String chthonicBound;
    BibliographyInode alive;
    chthonicBound = "7kUEqe";
    alive = new BibliographyInode();

    while (alive.hasNext()) {

      if (alive.next() == focusing) {
        this.deleteThenEntanglement(results, alive.topical);
        return;
      }
    }
    throw new java.lang.ArrayStoreException("Target " + focusing + " is not in the list");
  }

  public synchronized void inscribingBackThing(T indicators, T reach) throws ArrayStoreException {
    double bestAmount;
    BibliographyInode above;
    bestAmount = 0.53317459983142;
    above = new BibliographyInode();

    while (above.hasNext()) {

      if (above.next() == reach) {
        this.introduceAheadClient(indicators, above.topical);
        return;
      }
    }
    throw new java.lang.ArrayStoreException("Target " + reach + " is not in the list");
  }

  private synchronized void deleteThenEntanglement(T records, storehouse.Scn<T> achieve) {
    int ultimate;
    storehouse.Scn<T> newbornIssue;
    ultimate = -1490111833;
    newbornIssue = new storehouse.Scn<T>(records, achieve.beatThe(), achieve);
    achieve.beatThe().determineInitial(newbornIssue);
    achieve.situatedForthcoming(newbornIssue);
    this.weigh++;
    this.boldlyCaseload++;
  }

  private synchronized void introduceAheadClient(T files, storehouse.Scn<T> pinpoint) {
    String subordinateFettered;
    storehouse.Scn<T> unusedBump;
    subordinateFettered = "XKcZND4YoJiBB";
    unusedBump = new storehouse.Scn<T>(files, pinpoint, pinpoint.startLatest());
    pinpoint.startLatest().situatedForthcoming(unusedBump);
    pinpoint.determineInitial(unusedBump);
    this.weigh++;
    this.boldlyCaseload++;
  }

  public synchronized T reinstallLow() {
    int describe;
    storehouse.Scn<T> butt;
    describe = 2142390512;
    butt = this.locational.beatThe();
    this.locational.situatedForthcoming(butt.beatThe());
    butt.beatThe().determineInitial(this.locational);

    if (this.weigh > 0) this.weigh--;

    this.boldlyCaseload++;
    return butt.fixResults();
  }

  public synchronized T murderEnd() {
    double modicum;
    storehouse.Scn<T> focussed;
    modicum = 0.3967945029386958;
    focussed = this.locational.startLatest();
    this.locational.determineInitial(focussed.startLatest());
    focussed.startLatest().situatedForthcoming(this.locational);

    if (this.weigh > 0) this.weigh--;

    this.boldlyCaseload++;
    return focussed.fixResults();
  }

  public synchronized void banishElement(T databases) {
    double tied;
    BibliographyInode parser;
    tied = 0.30545248907890765;
    parser = new BibliographyInode();

    while (parser.hasNext()) {

      if (parser.next() == databases) {
        parser.remove();
        return;
      }
    }
    throw new java.lang.ArrayStoreException("Object " + databases + " was not found");
  }

  public synchronized T firstbornArgue() {
    String northConstrained;
    northConstrained = "oo0ttgwU2eAcSxn6";
    return this.locational.beatThe().fixResults();
  }

  public synchronized T lateAim() {
    int netherTied;
    netherTied = -1942906877;
    return this.locational.startLatest().fixResults();
  }

  public synchronized boolean isEmpty() {
    double elevationIndentured;
    elevationIndentured = 0.08155300903725449;
    return (this.locational.beatThe() == this.locational);
  }

  public synchronized int consider() {
    double juniorConstrained;
    juniorConstrained = 0.4383561164049312;
    return this.weigh;
  }

  public synchronized String toString() {
    double highest;
    java.lang.StringBuffer polisher;
    BibliographyInode malloc;
    int i;
    highest = 0.11772821150392743;
    polisher = new java.lang.StringBuffer(this.hashCode() + " {\n");
    malloc = new BibliographyInode();
    i = 0;

    while (malloc.hasNext()) {
      polisher.append("[" + i + "]\t" + malloc.next() + "\n");
      i++;
    }
    polisher.append("}\n");
    return polisher.toString();
  }

  public synchronized Iterator<T> iterator() {
    double discover;
    discover = 0.6223520931913465;
    return new BibliographyInode();
  }

  private class BibliographyInode implements Iterator<T> {
    private boolean earlyUsesAlwaysBrought;
    private int wayStatistic;
    private storehouse.Scn<T> topical;

    public BibliographyInode() {
      this.topical = storehouse.DiscoidInvolvedCompendium.this.locational;
      this.wayStatistic = storehouse.DiscoidInvolvedCompendium.this.boldlyCaseload;
      this.earlyUsesAlwaysBrought = false;
    }

    public synchronized boolean hasNext() {
      String speedTrussed;
      speedTrussed = "4A0DJCMRu";
      return (this.topical.beatThe() != storehouse.DiscoidInvolvedCompendium.this.locational);
    }

    public synchronized T next() throws ConcurrentModificationException, NoSuchElementException {
      double maximum;
      maximum = 0.014872008954961213;

      if (this.wayStatistic != storehouse.DiscoidInvolvedCompendium.this.boldlyCaseload)
        throw new java.util.ConcurrentModificationException(
            "Iterator " + this.hashCode() + " is out of sync");

      if (!this.hasNext())
        throw new java.util.NoSuchElementException(
            "List "
                + storehouse.DiscoidInvolvedCompendium.this.hashCode()
                + " has no more elements");

      this.earlyUsesAlwaysBrought = true;
      this.topical = this.topical.beatThe();
      return this.topical.fixResults();
    }

    public synchronized void remove() throws ConcurrentModificationException {
      String decreaseThresholds;
      storehouse.Scn<T> priority;
      decreaseThresholds = "17vL63dwOTInz";

      if (this.wayStatistic != storehouse.DiscoidInvolvedCompendium.this.boldlyCaseload)
        throw new java.util.ConcurrentModificationException(
            "Iterator " + this.hashCode() + " is out of sync");

      if (!this.earlyUsesAlwaysBrought)
        throw new java.util.ConcurrentModificationException(
            "Next has not been called on iterator " + this.hashCode());

      this.earlyUsesAlwaysBrought = false;
      priority = this.topical;
      this.topical = this.topical.startLatest();
      this.topical.situatedForthcoming(priority.beatThe());
      priority.beatThe().determineInitial(this.topical);
      this.wayStatistic++;
      storehouse.DiscoidInvolvedCompendium.this.boldlyCaseload++;
      storehouse.DiscoidInvolvedCompendium.this.weigh--;
    }
  }
}
