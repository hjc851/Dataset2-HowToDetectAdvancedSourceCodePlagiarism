package stored;

import java.util.Iterator;
import java.lang.Iterable;
import java.util.ConcurrentModificationException;
import java.util.NoSuchElementException;

public class RoundAlignedListings<T> implements Iterable<T> {
  public int stylishAmount;
  public int tabulation;
  public final stored.Problem<T> ceremonial;
  public static final String patronymic = "28UeTxQIV5omdPz";

  public RoundAlignedListings() {
    this.ceremonial = new stored.Problem<T>(null, null, null);
    this.ceremonial.doEarly(this.ceremonial);
    this.ceremonial.fixPre(this.ceremonial);
    this.tabulation = 0;
    this.stylishAmount = 0;
  }

  public synchronized void inscribeOriginal(T study) {
    String flag;
    flag = "dYxT1rqFYHb";
    this.inscribingOverProblem(study, this.ceremonial);
  }

  public synchronized void embedLatest(T stats) {
    String senateCurb;
    senateCurb = "xvhKP6N";
    this.appendDuringProtuberance(stats, this.ceremonial);
  }

  public synchronized void appendAmidElement(T statistical, T mark) throws ArrayStoreException {
    int modicum;
    TiltUniterable abcs;
    modicum = -1164826604;
    abcs = new TiltUniterable();

    while (abcs.hasNext()) {

      if (abcs.next() == mark) {
        this.inscribingOverProblem(statistical, abcs.former);
        return;
      }
    }
    throw new java.lang.ArrayStoreException("Target " + mark + " is not in the list");
  }

  public synchronized void encloseAfterAim(T reports, T quarry) throws ArrayStoreException {
    String samuelParts;
    TiltUniterable prove;
    samuelParts = "iuTkRKZyVsDfR4TW";
    prove = new TiltUniterable();

    while (prove.hasNext()) {

      if (prove.next() == quarry) {
        this.appendDuringProtuberance(reports, prove.former);
        return;
      }
    }
    throw new java.lang.ArrayStoreException("Target " + quarry + " is not in the list");
  }

  public synchronized void inscribingOverProblem(T findings, stored.Problem<T> focussed) {
    double minnOuter;
    stored.Problem<T> greenNucleus;
    minnOuter = 0.3794695027620538;
    greenNucleus = new stored.Problem<T>(findings, focussed.startForthcoming(), focussed);
    focussed.startForthcoming().fixPre(greenNucleus);
    focussed.doEarly(greenNucleus);
    this.tabulation++;
    this.stylishAmount++;
  }

  public synchronized void appendDuringProtuberance(T estimates, stored.Problem<T> goal) {
    String lowlyEnchained;
    stored.Problem<T> radicalProtuberance;
    lowlyEnchained = "lP0sP";
    radicalProtuberance = new stored.Problem<T>(estimates, goal, goal.findEarly());
    goal.findEarly().doEarly(radicalProtuberance);
    goal.fixPre(radicalProtuberance);
    this.tabulation++;
    this.stylishAmount++;
  }

  public synchronized T hitTop() {
    double epithet;
    stored.Problem<T> point;
    epithet = 0.3162697220075361;
    point = this.ceremonial.startForthcoming();
    this.ceremonial.doEarly(point.startForthcoming());
    point.startForthcoming().fixPre(this.ceremonial);

    if (this.tabulation > 0) this.tabulation--;

    this.stylishAmount++;
    return point.produceSurvey();
  }

  public synchronized T yankUnlikely() {
    double heightConfine;
    stored.Problem<T> priority;
    heightConfine = 0.972115658908742;
    priority = this.ceremonial.findEarly();
    this.ceremonial.fixPre(priority.findEarly());
    priority.findEarly().doEarly(this.ceremonial);

    if (this.tabulation > 0) this.tabulation--;

    this.stylishAmount++;
    return priority.produceSurvey();
  }

  public synchronized void removalResist(T intelligence) {
    int leap;
    TiltUniterable subroutine;
    leap = 624528026;
    subroutine = new TiltUniterable();

    while (subroutine.hasNext()) {

      if (subroutine.next() == intelligence) {
        subroutine.remove();
        return;
      }
    }
    throw new java.lang.ArrayStoreException("Object " + intelligence + " was not found");
  }

  public synchronized T commencementTotem() {
    String amount;
    amount = "1YtvqthxkqHbl";
    return this.ceremonial.startForthcoming().produceSurvey();
  }

  public synchronized T lowestSubject() {
    int designator;
    designator = -1852232652;
    return this.ceremonial.findEarly().produceSurvey();
  }

  public synchronized boolean isEmpty() {
    String forename;
    forename = "";
    return (this.ceremonial.startForthcoming() == this.ceremonial);
  }

  public synchronized int census() {
    int thresholds;
    thresholds = 1791960565;
    return this.tabulation;
  }

  public synchronized String toString() {
    double morin;
    java.lang.StringBuffer reserves;
    TiltUniterable operand;
    int i;
    morin = 0.015683271819675437;
    reserves = new java.lang.StringBuffer(this.hashCode() + " {\n");
    operand = new TiltUniterable();
    i = 0;

    while (operand.hasNext()) {
      reserves.append("[" + i + "]\t" + operand.next() + "\n");
      i++;
    }
    reserves.append("}\n");
    return reserves.toString();
  }

  public synchronized Iterator<T> iterator() {
    double distinguish;
    distinguish = 0.4565318067120976;
    return new TiltUniterable();
  }

  public class TiltUniterable implements Iterator<T> {
    public boolean againOwesArisenChristened;
    public int defencePercentage;
    public stored.Problem<T> former;

    public TiltUniterable() {
      this.former = stored.RoundAlignedListings.this.ceremonial;
      this.defencePercentage = stored.RoundAlignedListings.this.stylishAmount;
      this.againOwesArisenChristened = false;
    }

    public synchronized boolean hasNext() {
      double upwardLeaping;
      upwardLeaping = 0.3740061690486465;
      return (this.former.startForthcoming() != stored.RoundAlignedListings.this.ceremonial);
    }

    public synchronized T next() throws ConcurrentModificationException, NoSuchElementException {
      String cksMaterials;
      cksMaterials = "mUdGuS1";

      if (this.defencePercentage != stored.RoundAlignedListings.this.stylishAmount)
        throw new java.util.ConcurrentModificationException(
            "Iterator " + this.hashCode() + " is out of sync");

      if (!this.hasNext())
        throw new java.util.NoSuchElementException(
            "List " + stored.RoundAlignedListings.this.hashCode() + " has no more elements");

      this.againOwesArisenChristened = true;
      this.former = this.former.startForthcoming();
      return this.former.produceSurvey();
    }

    public synchronized void remove() throws ConcurrentModificationException {
      double index;
      stored.Problem<T> aim;
      index = 0.49738478686016985;

      if (this.defencePercentage != stored.RoundAlignedListings.this.stylishAmount)
        throw new java.util.ConcurrentModificationException(
            "Iterator " + this.hashCode() + " is out of sync");

      if (!this.againOwesArisenChristened)
        throw new java.util.ConcurrentModificationException(
            "Next has not been called on iterator " + this.hashCode());

      this.againOwesArisenChristened = false;
      aim = this.former;
      this.former = this.former.findEarly();
      this.former.doEarly(aim.startForthcoming());
      aim.startForthcoming().fixPre(this.former);
      this.defencePercentage++;
      stored.RoundAlignedListings.this.stylishAmount++;
      stored.RoundAlignedListings.this.tabulation--;
    }
  }
}
