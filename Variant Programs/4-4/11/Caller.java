import java.util.*;

public class Caller {
  private java.util.LinkedList<Proceeding> AzimuthMethodologies = null;

  private synchronized void leanController(
      Outliner multitasking,
      java.util.LinkedList<Proceeding> prevailingProcedure,
      java.lang.String fallback) {
    multitasking.originateConfiguration(fallback);
    java.util.Collections.sort(prevailingProcedure);

    while (!prevailingProcedure.isEmpty()) synx80(multitasking, prevailingProcedure);

    while (multitasking.goIsMoving()) synx81(multitasking, fallback);
  }

  public Caller() {
    Outliner a;
    this.available = new java.util.ArrayDeque<>();
    a = new IccParser();
    this.available.addLast(a);
  }

  private java.util.ArrayDeque<Outliner> available = null;

  public synchronized void readyReplacementMarch(java.util.LinkedList<Proceeding> systems) {
    this.atkinsMechanisms = systems.size();
    this.AzimuthMethodologies = systems;
  }

  private java.util.LinkedList<Proceeding> AlarmTechnologies = null;
  private int atkinsMechanisms = 0;

  public synchronized void testDistributors() {
    this.leanController(new IccParser(), this.AzimuthMethodologies, "LRU");
    this.leanController(new IccParser(), this.AlarmTechnologies, "CLOCK");
  }

  public synchronized void arrangedTimerAct(java.util.LinkedList<Proceeding> method) {
    this.atkinsMechanisms = method.size();
    this.AlarmTechnologies = method;
  }

  private synchronized void synx80(
      Outliner multitasking, java.util.LinkedList<Proceeding> prevailingProcedure) {
    multitasking.arrivalMethodology(prevailingProcedure.removeFirst());
  }

  private synchronized void synx81(Outliner multitasking, String fallback) {

    if (multitasking.obtainFinishedOutgrowthLength() == atkinsMechanisms) {
      multitasking.discontinueTimer(fallback);
    } else {
      multitasking.arrangeExistingDial(multitasking.takeTopicalMark() + 1);
      multitasking.weapMark();
    }
  }
}
