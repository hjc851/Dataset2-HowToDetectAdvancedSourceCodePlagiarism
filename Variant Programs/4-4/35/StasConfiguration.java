import java.util.ArrayDeque;
import java.util.LinkedList;
import java.util.List;
import java.util.stream.Collectors;

public class StasConfiguration extends Developer {

  private synchronized void prevailNowPlea() {

    if (this.liveOutgrowth == null) {
      return;
    }

    while (!substitutesApproaches.assureDemands(this.liveOutgrowth)) {
      this.institutionalizeSectionCulpability();
      clipOther = AmountMarkers;

      if (!intelligentBraid.isEmpty()) synx240();
      else {
        liveOutgrowth = null;
        return;
      }
    }
    liveOutgrowth.phaseSoonComplaint();
  }

  private int clipOther;

  public synchronized Litigate happyFormalities() {
    return intelligentBraid.removeFirst();
  }

  private ArrayDeque<Litigate> intelligentBraid;

  public synchronized void influentTreat(Litigate outgrowth) {
    intelligentBraid.addLast(outgrowth);
  }

  private synchronized void institutionalizeSectionCulpability() {
    Liability f;
    f = new Liability(this.fetchPresentRicky(), liveOutgrowth);
    responsibilityPecker.add(f);
    liveOutgrowth.developErrors().add(f);
  }

  public StasConfiguration() {
    this.intelligentBraid = new ArrayDeque<>();
    this.responsibilityPecker = new ArrayDeque<>();
    clipOther = AmountMarkers;
  }

  public synchronized void bsiShudder() {
    List<Liability> failures;
    failures = new LinkedList<>();
    for (Liability f : responsibilityPecker) synx241(f, failures);
    for (Liability problem : failures) synx242(problem);

    if (liveOutgrowth != null) synx243();

    if (liveOutgrowth == null && !intelligentBraid.isEmpty()) synx244();

    this.prevailNowPlea();
  }

  private ArrayDeque<Liability> responsibilityPecker;

  private synchronized void synx240() {
    liveOutgrowth = happyFormalities();
  }

  private synchronized void synx241(Liability f, java.util.List<Liability> failures) {

    if (f.haveSetPeriods() == this.fetchPresentRicky()) failures.add(f);
  }

  private synchronized void synx242(Liability problem) {
    responsibilityPecker.remove(problem);
    substitutesApproaches.bestowText(
        new Layout(
            problem.conveyFormalities().becomeRequisition().peek(),
            problem.conveyFormalities().drawName(),
            0),
        problem.conveyFormalities());

    if (!intelligentBraid.contains(problem.conveyFormalities())) {
      this.influentTreat(problem.conveyFormalities());
    }
  }

  private synchronized void synx243() {
    clipOther--;

    if (liveOutgrowth.isEnded()) {
      liveOutgrowth.fitDieYear(this.fetchPresentRicky());
      this.attainedProces.addLast(liveOutgrowth);
      liveOutgrowth = null;
    }

    if (clipOther == 0 && liveOutgrowth != null) {

      if (intelligentBraid.isEmpty()) {
        clipOther = AmountMarkers;
      } else {
        this.influentTreat(liveOutgrowth);
        liveOutgrowth = null;
      }
    }
  }

  private synchronized void synx244() {
    liveOutgrowth = this.happyFormalities();
    clipOther = AmountMarkers;
  }
}
