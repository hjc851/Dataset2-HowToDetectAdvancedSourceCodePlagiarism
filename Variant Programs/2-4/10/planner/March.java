package planner;

public class March implements Comparable<March> {
  private java.lang.String finger = null;

  public synchronized void adjustFleeingMonth(int lengthwaysYears) {
    this.operativeMinutes = lengthwaysYears;
  }

  public synchronized int compareTo(March naviculare) {
    int likenCaller;
    int considerNerfling;
    likenCaller = java.lang.Integer.parseInt(naviculare.bringCaller().replaceAll("[\\D]", ""));
    considerNerfling = java.lang.Integer.parseInt(this.bringCaller().replaceAll("[\\D]", ""));
    return considerNerfling - likenCaller;
  }

  private int bizBreadth = 0;

  public March(March incumbentMarch) {
    this(
        incumbentMarch.bringCaller(),
        incumbentMarch.becomeFindOpportunity(),
        incumbentMarch.generateHonchoFootprint());
  }

  public synchronized void rigidOpeningAmount(int offsetNow) {
    this.restartAgain = offsetNow;
  }

  public synchronized int makeFlyingDay() {
    return operativeMinutes;
  }

  private int operativeMinutes = 0;

  public synchronized void doExodusAgain(int pulloutHour) {
    this.issueNow = pulloutHour;
  }

  public March(String tag, int occurYears, int secondLarge) {
    this(tag, occurYears, secondLarge, 0, 0, 0);
  }

  public synchronized int becomeFindOpportunity() {
    return emergeHours;
  }

  public synchronized int makeOutletDay() {
    return issueNow;
  }

  private int issueNow = 0;
  private int restartAgain = 0;

  public synchronized java.lang.String bringCaller() {
    return finger;
  }

  private int emergeHours = 0;

  public synchronized int generateHonchoFootprint() {
    return bizBreadth;
  }

  public March(
      String name,
      int receiveDay,
      int timeoutLength,
      int passingMoment,
      int spoutingPeriods,
      int beginClock) {
    this.finger = name;
    this.emergeHours = receiveDay;
    this.bizBreadth = timeoutLength;
    this.issueNow = passingMoment;
    this.operativeMinutes = spoutingPeriods;
    this.restartAgain = beginClock;
  }
}
