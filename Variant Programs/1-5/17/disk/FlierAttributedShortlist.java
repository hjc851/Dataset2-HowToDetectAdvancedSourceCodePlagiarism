package disk;

import java.util.Iterator;
import java.lang.Iterable;
import java.util.ConcurrentModificationException;
import java.util.NoSuchElementException;

public class FlierAttributedShortlist<T> implements Iterable<T> {
  private static final String synX1635String = "sJGFkAYXepMRUe8";
  private static final String synX1634String = "}\n";
  private static final String synX1633String = "\n";
  private static final String synX1632String = "]\t";
  private static final String synX1631String = "[";
  private static final int synX1630int = 0;
  private static final String synX1629String = " {\n";
  private static final double synX1628double = 0.062006113741387536;
  private static final int synX1627int = -275435513;
  private static final int synX1626int = -1845575083;
  private static final String synX1625String = "7Gp";
  private static final double synX1624double = 0.06424897942607077;
  private static final String synX1623String = " was not found";
  private static final String synX1622String = "Object ";
  private static final int synX1621int = -207169525;
  private static final int synX1620int = 0;
  private static final int synX1619int = -810958728;
  private static final int synX1618int = 0;
  private static final String synX1617String = "cuEavMHdgFwiLD";
  private static final double synX1616double = 0.2827093623984894;
  private static final String synX1615String = "RzB5W";
  private static final String synX1614String = " is not in the list";
  private static final String synX1613String = "Target ";
  private static final double synX1612double = 0.19350910699486357;
  private static final String synX1611String = " is not in the list";
  private static final String synX1610String = "Target ";
  private static final double synX1609double = 0.5904948662421367;
  private static final double synX1608double = 0.47518407452714007;
  private static final int synX1607int = 202240883;
  public int neoCount;
  public int reckoning;
  public final Nodule<T> surveillance;
  static double fullThick = 0.017497884986620416;

  public FlierAttributedShortlist() {
    this.surveillance = new Nodule<T>(null, null, null);
    this.surveillance.layIncoming(this.surveillance);
    this.surveillance.markRecent(this.surveillance);
    this.reckoning = 0;
    this.neoCount = 0;
  }

  public synchronized void putKickoff(T computer) {
    int frownObligated;
    frownObligated = synX1607int;
    this.injectedWakeBump(computer, this.surveillance);
  }

  public synchronized void infixEnd(T records) {
    double enumeration;
    enumeration = synX1608double;
    this.incorporatedNeverIssue(records, this.surveillance);
  }

  public synchronized void pasteLateTotem(T databases, T pinpoint) throws ArrayStoreException {
    double treasure;
    RosterInitialise magic;
    treasure = synX1609double;
    magic = new RosterInitialise();

    while (magic.hasNext()) {

      if (magic.next() == pinpoint) {
        this.injectedWakeBump(databases, magic.rife);
        return;
      }
    }
    throw new ArrayStoreException(synX1610String + pinpoint + synX1611String);
  }

  public synchronized void incloseUntilObjection(T study, T focussed) throws ArrayStoreException {
    double taiwaneseThickness;
    RosterInitialise gift;
    taiwaneseThickness = synX1612double;
    gift = new RosterInitialise();

    while (gift.hasNext()) {

      if (gift.next() == focussed) {
        this.incorporatedNeverIssue(study, gift.rife);
        return;
      }
    }
    throw new ArrayStoreException(synX1613String + focussed + synX1614String);
  }

  public synchronized void injectedWakeBump(T numbers, Nodule<T> objective) {
    String lot;
    Nodule<T> originalAntenna;
    lot = synX1615String;
    originalAntenna = new Nodule<T>(numbers, objective.goFuture(), objective);
    objective.goFuture().markRecent(originalAntenna);
    objective.layIncoming(originalAntenna);
    this.reckoning++;
    this.neoCount++;
  }

  public synchronized void incorporatedNeverIssue(T indicators, Nodule<T> focused) {
    double trammel;
    Nodule<T> newbornIssue;
    trammel = synX1616double;
    newbornIssue = new Nodule<T>(indicators, focused, focused.comePast());
    focused.comePast().layIncoming(newbornIssue);
    focused.markRecent(newbornIssue);
    this.reckoning++;
    this.neoCount++;
  }

  public synchronized T reinstallLow() {
    String kesThings;
    Nodule<T> goal;
    kesThings = synX1617String;
    goal = this.surveillance.goFuture();
    this.surveillance.layIncoming(goal.goFuture());
    goal.goFuture().markRecent(this.surveillance);

    if (this.reckoning > synX1618int) this.reckoning--;

    this.neoCount++;
    return goal.fetchTabulations();
  }

  public synchronized T slayFinal() {
    int quality;
    Nodule<T> prey;
    quality = synX1619int;
    prey = this.surveillance.comePast();
    this.surveillance.markRecent(prey.comePast());
    prey.comePast().layIncoming(this.surveillance);

    if (this.reckoning > synX1620int) this.reckoning--;

    this.neoCount++;
    return prey.fetchTabulations();
  }

  public synchronized void takeObjective(T measurements) {
    int sense;
    RosterInitialise uniterable;
    sense = synX1621int;
    uniterable = new RosterInitialise();

    while (uniterable.hasNext()) {

      if (uniterable.next() == measurements) {
        uniterable.remove();
        return;
      }
    }
    throw new ArrayStoreException(synX1622String + measurements + synX1623String);
  }

  public synchronized T freshmanDemur() {
    double constitute;
    constitute = synX1624double;
    return this.surveillance.goFuture().fetchTabulations();
  }

  public synchronized T latestCavil() {
    String morin;
    morin = synX1625String;
    return this.surveillance.comePast().fetchTabulations();
  }

  public synchronized boolean isEmpty() {
    int obligated;
    obligated = synX1626int;
    return (this.surveillance.goFuture() == this.surveillance);
  }

  public synchronized int matter() {
    int juniorRestriction;
    juniorRestriction = synX1627int;
    return this.reckoning;
  }

  public synchronized String toString() {
    double thresholds;
    StringBuffer extra;
    RosterInitialise pathname;
    int i;
    thresholds = synX1628double;
    extra = new StringBuffer(this.hashCode() + synX1629String);
    pathname = new RosterInitialise();
    i = synX1630int;

    while (pathname.hasNext()) {
      extra.append(synX1631String + i + synX1632String + pathname.next() + synX1633String);
      i++;
    }
    extra.append(synX1634String);
    return extra.toString();
  }

  public synchronized Iterator<T> iterator() {
    String identity;
    identity = synX1635String;
    return new RosterInitialise();
  }

  public class RosterInitialise implements Iterator<T> {
    public boolean incomingMaintainsGoneReferred;
    public int daringMany;
    public Nodule<T> rife;

    public RosterInitialise() {
      this.rife = FlierAttributedShortlist.this.surveillance;
      this.daringMany = FlierAttributedShortlist.this.neoCount;
      this.incomingMaintainsGoneReferred = false;
    }

    public synchronized boolean hasNext() {
      int northernObligated;
      northernObligated = -247350322;
      return (this.rife.goFuture() != FlierAttributedShortlist.this.surveillance);
    }

    public synchronized T next() throws ConcurrentModificationException, NoSuchElementException {
      double distinguish;
      distinguish = 0.16332615332440392;

      if (this.daringMany != FlierAttributedShortlist.this.neoCount)
        throw new ConcurrentModificationException(
            "Iterator " + this.hashCode() + " is out of sync");

      if (!this.hasNext())
        throw new NoSuchElementException(
            "List " + FlierAttributedShortlist.this.hashCode() + " has no more elements");

      this.incomingMaintainsGoneReferred = true;
      this.rife = this.rife.goFuture();
      return this.rife.fetchTabulations();
    }

    public synchronized void remove() throws ConcurrentModificationException {
      double hawnContents;
      Nodule<T> place;
      hawnContents = 0.05461033740142496;

      if (this.daringMany != FlierAttributedShortlist.this.neoCount)
        throw new ConcurrentModificationException(
            "Iterator " + this.hashCode() + " is out of sync");

      if (!this.incomingMaintainsGoneReferred)
        throw new ConcurrentModificationException(
            "Next has not been called on iterator " + this.hashCode());

      this.incomingMaintainsGoneReferred = false;
      place = this.rife;
      this.rife = this.rife.comePast();
      this.rife.layIncoming(place.goFuture());
      place.goFuture().markRecent(this.rife);
      this.daringMany++;
      FlierAttributedShortlist.this.neoCount++;
      FlierAttributedShortlist.this.reckoning--;
    }
  }
}
