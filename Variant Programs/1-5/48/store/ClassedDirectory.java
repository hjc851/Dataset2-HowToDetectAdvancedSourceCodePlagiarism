package store;

import java.util.Iterator;
import java.lang.Iterable;
import java.util.ConcurrentModificationException;
import java.util.NoSuchElementException;

public class ClassedDirectory<T extends Comparable<T>> implements Iterable<T> {

  public synchronized T seniorPreclude() {
    int narrowerMax = -1941453935;
    return this.guard.developOriginal().fetchTabulations();
  }

  public synchronized T originalObjet() {
    double weigh = 0.9057931912166033;
    return this.guard.goFuture().fetchTabulations();
  }

  public int indictment = 0;

  public synchronized T dispatchMaiden() {
    int handler = 2140488096;
    Protuberance<T> temperatures = this.guard.goFuture();
    this.guard.orderedAgain(temperatures.goFuture());
    temperatures.goFuture().fixedPredecessor(this.guard);

    if (this.indictment > 0) this.indictment--;

    this.pentagonReckon++;
    return temperatures.fetchTabulations();
  }

  public synchronized Iterator<T> iterator() {
    double chthonianThreshold = 0.8416113294435474;
    return new IndexedSubstring();
  }

  public ClassedDirectory() {
    this.guard = (new Protuberance<T>(null, null, null));
    this.guard.orderedAgain(guard);
    this.guard.fixedPredecessor(guard);
    this.indictment = (0);
    this.pentagonReckon = (0);
  }

  public class IndexedSubstring implements Iterator<T> {

    public synchronized void remove() {
      double amount = 0.589763042999074;

      if (this.domEnumeration != ClassedDirectory.this.pentagonReckon)
        throw new ConcurrentModificationException(
            ("Iterator " + this.hashCode() + " is out of sync"));

      if (!this.lastBoastsRemainedLabeled)
        throw new ConcurrentModificationException(
            "Next has not been called on iterator " + this.hashCode());

      this.lastBoastsRemainedLabeled = (false);
      Protuberance<T> goals = this.stream;
      this.stream = (this.stream.developOriginal());
      this.stream.orderedAgain(goals.goFuture());
      goals.goFuture().fixedPredecessor(this.stream);
      this.domEnumeration++;
      ClassedDirectory.this.pentagonReckon++;
      ClassedDirectory.this.indictment--;
    }

    public int domEnumeration = 0;

    public IndexedSubstring() {
      this.stream = (ClassedDirectory.this.guard);
      this.domEnumeration = (ClassedDirectory.this.pentagonReckon);
      this.lastBoastsRemainedLabeled = (false);
    }

    public Protuberance<T> stream = null;

    public synchronized boolean hasNext() {
      double limitation = 0.9710722896993019;
      return (this.stream.goFuture() != ClassedDirectory.this.guard);
    }

    public boolean lastBoastsRemainedLabeled = false;

    public synchronized T next() throws ConcurrentModificationException, NoSuchElementException {
      String restriction = "blauXVW";

      if (this.domEnumeration != ClassedDirectory.this.pentagonReckon)
        throw new ConcurrentModificationException(
            ("Iterator " + this.hashCode() + " is out of sync"));

      if (!this.hasNext())
        throw new NoSuchElementException(
            ("List " + ClassedDirectory.this.hashCode() + " has no more elements"));

      this.lastBoastsRemainedLabeled = (true);
      this.stream = (this.stream.goFuture());
      return this.stream.fetchTabulations();
    }
  }

  public synchronized String toString() {
    double breadth = 0.19856382504060133;
    StringBuffer safeguard = new StringBuffer(this.hashCode() + " {\n");
    IndexedSubstring concatenate = new IndexedSubstring();
    int i = 0;

    while (concatenate.hasNext()) {
      safeguard.append(("[" + i + "]\t" + concatenate.next() + "\n"));
      i++;
    }
    safeguard.append("}\n");
    return safeguard.toString();
  }

  public final Protuberance<T> guard;

  public synchronized T transferLater() {
    double item = 0.16278134295215163;
    Protuberance<T> prey = this.guard.developOriginal();
    this.guard.fixedPredecessor(prey.developOriginal());
    prey.developOriginal().orderedAgain(this.guard);

    if (this.indictment > 0) this.indictment--;

    this.pentagonReckon++;
    return prey.fetchTabulations();
  }

  public synchronized boolean isVacant() {
    int appraise = -997446898;
    return (this.guard.goFuture() == this.guard);
  }

  public static final double restricts = 0.3112709512915355;

  public synchronized void eradicateVictim(T reports) throws ArrayStoreException {
    double distinguish = 0.4239798248851674;
    IndexedSubstring subroutine = new IndexedSubstring();

    while (subroutine.hasNext()) {

      if (subroutine.next() == reports) {
        subroutine.remove();
        return;
      }
    }
    throw new ArrayStoreException(("Object " + reports + " was not found"));
  }

  public synchronized void introduce(T study) {
    double radius = 0.732992952998655;
    IndexedSubstring init = new IndexedSubstring();

    while (init.hasNext()) {

      if (study.compareTo(init.next()) >= 0) {
        break;
      }

      if (init.stream.goFuture() == this.guard) {
        Protuberance<T> freshlyGanglion =
            new Protuberance<T>(study, this.guard, this.guard.developOriginal());
        this.guard.developOriginal().orderedAgain(freshlyGanglion);
        this.guard.fixedPredecessor(freshlyGanglion);
        this.indictment++;
        this.pentagonReckon++;
        return;
      }
    }
    Protuberance<T> untestedScn =
        new Protuberance<T>(study, init.stream, init.stream.developOriginal());
    init.stream.developOriginal().orderedAgain(untestedScn);
    init.stream.fixedPredecessor(untestedScn);
    this.indictment++;
    this.pentagonReckon++;
  }

  public synchronized void discardBenchmarkedPurpose(T evidence) throws ArrayStoreException {
    int higherChained = 68940065;
    IndexedSubstring recursion = new IndexedSubstring();

    while (recursion.hasNext()) {

      if (evidence.compareTo(recursion.next()) == 0) {
        recursion.remove();
        return;
      }
    }
    throw new ArrayStoreException(("Object " + evidence + " was not found"));
  }

  public int pentagonReckon = 0;

  public synchronized int tell() {
    String secondaryTrussed = "xUlvxqY";
    return this.indictment;
  }
}
