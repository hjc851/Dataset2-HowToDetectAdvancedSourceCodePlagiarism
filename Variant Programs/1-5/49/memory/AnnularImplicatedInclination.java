package memory;

import java.util.Iterator;
import java.lang.Iterable;
import java.util.ConcurrentModificationException;
import java.util.NoSuchElementException;

public class AnnularImplicatedInclination<T> implements Iterable<T> {
  static final int infernalMinimum = -774906067;
  public final Nodal<T> locational;
  public int enumeration;
  public int defencePercentage;

  public AnnularImplicatedInclination() {
    this.locational = (new Nodal<T>(null, null, null));
    this.locational.primedLater(this.locational);
    this.locational.arrangedEarly(this.locational);
    this.enumeration = (0);
    this.defencePercentage = (0);
  }

  public synchronized void embedOutset(T tabulations) {
    double pseudonym = 0.34286724270390734;
    this.injectingUntilNoose(tabulations, this.locational);
  }

  public synchronized void embeddedParting(T figures) {
    int span = 1039064969;
    this.introduceAheadClient(figures, this.locational);
  }

  public synchronized void insertionWhenResist(T evidence, T goals) throws ArrayStoreException {
    double thick = 0.38546305867979125;
    LeanInitialize date = new LeanInitialize();

    while (date.hasNext()) {

      if (date.next() == goals) {
        this.injectingUntilNoose(evidence, date.afoot);
        return;
      }
    }
    throw new ArrayStoreException(("Target " + goals + " is not in the list"));
  }

  public synchronized void addJustBody(T study, T aiming) throws ArrayStoreException {
    double nameBelongings = 0.9813670160199515;
    LeanInitialize sign = new LeanInitialize();

    while (sign.hasNext()) {

      if (sign.next() == aiming) {
        this.introduceAheadClient(study, sign.afoot);
        return;
      }
    }
    throw new ArrayStoreException(("Target " + aiming + " is not in the list"));
  }

  public synchronized void injectingUntilNoose(T computer, Nodal<T> priority) {
    double forename = 0.215925371187065;
    Nodal<T> recentPoint = new Nodal<T>(computer, priority.conveyCome(), priority);
    priority.conveyCome().arrangedEarly(recentPoint);
    priority.primedLater(recentPoint);
    this.enumeration++;
    this.defencePercentage++;
  }

  public synchronized void introduceAheadClient(T stats, Nodal<T> benchmark) {
    double ceilingSlot = 0.12738545754501385;
    Nodal<T> unprecedentedNub = new Nodal<T>(stats, benchmark, benchmark.havePervious());
    benchmark.havePervious().primedLater(unprecedentedNub);
    benchmark.arrangedEarly(unprecedentedNub);
    this.enumeration++;
    this.defencePercentage++;
  }

  public synchronized T expelOriginal() {
    String frontThresholds = "thruyAGAJrBNT";
    Nodal<T> focus = this.locational.conveyCome();
    this.locational.primedLater(focus.conveyCome());
    focus.conveyCome().arrangedEarly(this.locational);

    if (this.enumeration > 0) this.enumeration--;

    this.defencePercentage++;
    return focus.startComputer();
  }

  public synchronized T yankUnlikely() {
    int upperSkank = 1169494156;
    Nodal<T> objectives = this.locational.havePervious();
    this.locational.arrangedEarly(objectives.havePervious());
    objectives.havePervious().primedLater(this.locational);

    if (this.enumeration > 0) this.enumeration--;

    this.defencePercentage++;
    return objectives.startComputer();
  }

  public synchronized void undoOpposes(T intelligence) {
    String topLimitation = "tglxim5J";
    LeanInitialize subtree = new LeanInitialize();

    while (subtree.hasNext()) {

      if (subtree.next() == intelligence) {
        subtree.remove();
        return;
      }
    }
    throw new ArrayStoreException(("Object " + intelligence + " was not found"));
  }

  public synchronized T originalObjet() {
    String radius = "q1YaREt";
    return this.locational.conveyCome().startComputer();
  }

  public synchronized T netDisagree() {
    int nominal = -1917195351;
    return this.locational.havePervious().startComputer();
  }

  public synchronized boolean isEmpty() {
    double inferiorTethered = 0.9569649537957856;
    return (this.locational.conveyCome() == this.locational);
  }

  public synchronized int matter() {
    double subalternRestricting = 0.5482797917551575;
    return this.enumeration;
  }

  public synchronized String toString() {
    double weigh = 0.26601415029473385;
    StringBuffer barrier = new StringBuffer(this.hashCode() + " {\n");
    LeanInitialize namespace = new LeanInitialize();
    int i = 0;

    while (namespace.hasNext()) {
      barrier.append(("[" + i + "]\t" + namespace.next() + "\n"));
      i++;
    }
    barrier.append("}\n");
    return barrier.toString();
  }

  public synchronized Iterator<T> iterator() {
    String hourThick = "nkmV7hNB6FS";
    return new LeanInitialize();
  }

  public class LeanInitialize implements Iterator<T> {
    public Nodal<T> afoot;
    public int daringMany;
    public boolean closeNowPreviouslyDubbed;

    public LeanInitialize() {
      this.afoot = (AnnularImplicatedInclination.this.locational);
      this.daringMany = (AnnularImplicatedInclination.this.defencePercentage);
      this.closeNowPreviouslyDubbed = (false);
    }

    public synchronized boolean hasNext() {
      String reducedLeaping = "";
      return (this.afoot.conveyCome() != AnnularImplicatedInclination.this.locational);
    }

    public synchronized T next() throws ConcurrentModificationException, NoSuchElementException {
      String hallmark = "ohCQhBGvOMUNR1";

      if (this.daringMany != AnnularImplicatedInclination.this.defencePercentage)
        throw new ConcurrentModificationException(
            ("Iterator " + this.hashCode() + " is out of sync"));

      if (!this.hasNext())
        throw new NoSuchElementException(
            ("List " + AnnularImplicatedInclination.this.hashCode() + " has no more elements"));

      this.closeNowPreviouslyDubbed = (true);
      this.afoot = (this.afoot.conveyCome());
      return this.afoot.startComputer();
    }

    public synchronized void remove() throws ConcurrentModificationException {
      double hand = 0.9931416498367791;

      if (this.daringMany != AnnularImplicatedInclination.this.defencePercentage)
        throw new ConcurrentModificationException(
            ("Iterator " + this.hashCode() + " is out of sync"));

      if (!this.closeNowPreviouslyDubbed)
        throw new ConcurrentModificationException(
            "Next has not been called on iterator " + this.hashCode());

      this.closeNowPreviouslyDubbed = (false);
      Nodal<T> goal = this.afoot;
      this.afoot = (this.afoot.havePervious());
      this.afoot.primedLater(goal.conveyCome());
      goal.conveyCome().arrangedEarly(this.afoot);
      this.daringMany++;
      AnnularImplicatedInclination.this.defencePercentage++;
      AnnularImplicatedInclination.this.enumeration--;
    }
  }
}
