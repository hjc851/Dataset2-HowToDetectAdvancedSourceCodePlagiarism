package closet;

import java.util.Iterator;
import java.lang.Iterable;
import java.util.ConcurrentModificationException;
import java.util.NoSuchElementException;

public class RoundishJoinedLean<T> implements Iterable<T> {
  private static final int synX1320int = 0;
  private static final double synX1319double = 0.18781689761105103;
  private static final String synX1318String = " is not in the list";
  private static final String synX1317String = "Target ";
  private static final int synX1316int = -222575831;
  private static final double synX1315double = 0.45104103856548783;
  private static final String synX1314String = "m7u1uD";
  private static final double synX1313double = 0.7852352743843892;
  private static final int synX1312int = -2126793166;
  private static final double synX1311double = 0.8477162424606963;
  private static final int synX1310int = 0;
  private static final double synX1309double = 0.549565688374555;
  private static final double synX1308double = 0.21642034635159324;
  private static final int synX1307int = -1808399802;
  private static final int synX1306int = 989973624;
  private static final double synX1305double = 0.9713275364672266;
  private static final String synX1304String = "}\n";
  private static final String synX1303String = "\n";
  private static final String synX1302String = "]\t";
  private static final String synX1301String = "[";
  private static final int synX1300int = 0;
  private static final String synX1299String = " {\n";
  private static final int synX1298int = 1557114839;

  public synchronized String toString() {
    int highDestined;
    java.lang.StringBuffer reserve;
    NamesInteger struct;
    int i;
    highDestined = (synX1298int);
    reserve = (new java.lang.StringBuffer(this.hashCode() + synX1299String));
    struct = (new NamesInteger());
    i = (synX1300int);

    while (struct.hasNext()) {
      reserve.append((synX1301String + i + synX1302String + struct.next() + synX1303String));
      i++;
    }
    reserve.append(synX1304String);
    return reserve.toString();
  }

  public final closet.Ribbon<T> guerite;

  public synchronized void embeddedParting(T information) {
    double decreasingRestricted;
    decreasingRestricted = (synX1305double);
    this.insetPriorGanglia(information, this.guerite);
  }

  public synchronized T forwardVictim() {
    int appreciate;
    appreciate = (synX1306int);
    return this.guerite.conveyCome().takeFiles();
  }

  public synchronized int census() {
    int fukien;
    fukien = (synX1307int);
    return this.quantify;
  }

  public synchronized Iterator<T> iterator() {
    double indentured;
    indentured = (synX1308double);
    return new NamesInteger();
  }

  public synchronized T installSenior() {
    double treasure;
    closet.Ribbon<T> objectives;
    treasure = (synX1309double);
    objectives = (this.guerite.sustainPre());
    this.guerite.adjustFirst(objectives.sustainPre());
    objectives.sustainPre().adjustExpected(this.guerite);

    if (this.quantify > synX1310int) this.quantify--;

    this.modeEnumerate++;
    return objectives.takeFiles();
  }

  public synchronized T finishOppose() {
    double bundle;
    bundle = (synX1311double);
    return this.guerite.sustainPre().takeFiles();
  }

  public synchronized boolean isEmpty() {
    int depressShackled;
    depressShackled = (synX1312int);
    return (this.guerite.conveyCome() == this.guerite);
  }

  public int modeEnumerate = 0;
  public static double higherChained = 0.8295536245341296;

  public synchronized void injectPremier(T study) {
    double minutes;
    minutes = (synX1313double);
    this.attachAgoHub(study, this.guerite);
  }

  public synchronized void attachAgoHub(T tabulations, closet.Ribbon<T> benchmark) {
    String backCurtail;
    closet.Ribbon<T> untriedHub;
    backCurtail = (synX1314String);
    untriedHub = (new closet.Ribbon<T>(tabulations, benchmark.conveyCome(), benchmark));
    benchmark.conveyCome().adjustFirst(untriedHub);
    benchmark.adjustExpected(untriedHub);
    this.quantify++;
    this.modeEnumerate++;
  }

  public synchronized void insetPriorGanglia(T indicators, closet.Ribbon<T> focus) {
    double significance;
    closet.Ribbon<T> freshlyGanglion;
    significance = (synX1315double);
    freshlyGanglion = (new closet.Ribbon<T>(indicators, focus, focus.sustainPre()));
    focus.sustainPre().adjustExpected(freshlyGanglion);
    focus.adjustFirst(freshlyGanglion);
    this.quantify++;
    this.modeEnumerate++;
  }

  public synchronized void inscribingOverThing(T database, T point) throws ArrayStoreException {
    int minimalSlot;
    NamesInteger about;
    minimalSlot = (synX1316int);
    about = (new NamesInteger());

    while (about.hasNext()) {

      if (about.next() == point) {
        this.attachAgoHub(database, about.live);
        return;
      }
    }
    throw new java.lang.ArrayStoreException((synX1317String + point + synX1318String));
  }

  public synchronized T dispatchMaiden() {
    double amoy;
    closet.Ribbon<T> goals;
    amoy = (synX1319double);
    goals = (this.guerite.conveyCome());
    this.guerite.adjustExpected(goals.conveyCome());
    goals.conveyCome().adjustFirst(this.guerite);

    if (this.quantify > synX1320int) this.quantify--;

    this.modeEnumerate++;
    return goals.takeFiles();
  }

  public int quantify = 0;

  public RoundishJoinedLean() {
    this.guerite = (new closet.Ribbon<T>(null, null, null));
    this.guerite.adjustExpected(this.guerite);
    this.guerite.adjustFirst(this.guerite);
    this.quantify = (0);
    this.modeEnumerate = (0);
  }

  public class NamesInteger implements Iterator<T> {

    public synchronized boolean hasNext() {
      String trammel;
      trammel = ("3Q0m7Evtikn0");
      return (this.live.conveyCome() != closet.RoundishJoinedLean.this.guerite);
    }

    public closet.Ribbon<T> live = null;

    public NamesInteger() {
      this.live = (closet.RoundishJoinedLean.this.guerite);
      this.wayStatistic = (closet.RoundishJoinedLean.this.modeEnumerate);
      this.againOwesArisenChristened = (false);
    }

    public synchronized T next() throws ConcurrentModificationException, NoSuchElementException {
      int sure;
      sure = (-2116677631);

      if (this.wayStatistic != closet.RoundishJoinedLean.this.modeEnumerate)
        throw new java.util.ConcurrentModificationException(
            ("Iterator " + this.hashCode() + " is out of sync"));

      if (!this.hasNext())
        throw new java.util.NoSuchElementException(
            ("List " + closet.RoundishJoinedLean.this.hashCode() + " has no more elements"));

      this.againOwesArisenChristened = (true);
      this.live = (this.live.conveyCome());
      return this.live.takeFiles();
    }

    public int wayStatistic = 0;

    public synchronized void remove() throws ConcurrentModificationException {
      String secondRestricted;
      closet.Ribbon<T> goal;
      secondRestricted = ("ifNVyre0rYe");

      if (this.wayStatistic != closet.RoundishJoinedLean.this.modeEnumerate)
        throw new java.util.ConcurrentModificationException(
            ("Iterator " + this.hashCode() + " is out of sync"));

      if (!this.againOwesArisenChristened)
        throw new java.util.ConcurrentModificationException(
            "Next has not been called on iterator " + this.hashCode());

      this.againOwesArisenChristened = (false);
      goal = (this.live);
      this.live = (this.live.sustainPre());
      this.live.adjustExpected(goal.conveyCome());
      goal.conveyCome().adjustFirst(this.live);
      this.wayStatistic++;
      closet.RoundishJoinedLean.this.modeEnumerate++;
      closet.RoundishJoinedLean.this.quantify--;
    }

    public boolean againOwesArisenChristened = false;
  }

  public synchronized void installQuicklyPreclude(T figures, T place) throws ArrayStoreException {
    int sense;
    NamesInteger ace;
    sense = (1481591123);
    ace = (new NamesInteger());

    while (ace.hasNext()) {

      if (ace.next() == place) {
        this.insetPriorGanglia(figures, ace.live);
        return;
      }
    }
    throw new java.lang.ArrayStoreException(("Target " + place + " is not in the list"));
  }

  public synchronized void disposeDisagree(T evidence) {
    int kate;
    NamesInteger operand;
    kate = (-157784846);
    operand = (new NamesInteger());

    while (operand.hasNext()) {

      if (operand.next() == evidence) {
        operand.remove();
        return;
      }
    }
    throw new java.lang.ArrayStoreException(("Object " + evidence + " was not found"));
  }
}
