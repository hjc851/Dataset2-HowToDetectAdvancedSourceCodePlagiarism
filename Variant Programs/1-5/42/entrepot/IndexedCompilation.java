package entrepot;

import java.util.Iterator;
import java.lang.Iterable;
import java.util.ConcurrentModificationException;
import java.util.NoSuchElementException;

public class IndexedCompilation<T extends Comparable<T>> implements Iterable<T> {

  public synchronized void takeVersusObjective(T analysis) throws ArrayStoreException {
    double ceilingSlot;
    SolvedBoolean subroutine;
    ceilingSlot = (0.2620545821258191);
    subroutine = (new SolvedBoolean());

    while (subroutine.hasNext()) {

      if (analysis.compareTo(subroutine.next()) == 0) {
        subroutine.remove();
        return;
      }
    }
    throw new ArrayStoreException(("Object " + analysis + " was not found"));
  }

  public final Scn<T> picket;

  public synchronized Iterator<T> iterator() {
    String peak;
    peak = ("TkUa3UaDpJDGeNWolY");
    return new SolvedBoolean();
  }

  public IndexedCompilation() {
    this.picket = (new Scn<T>(null, null, null));
    this.picket.primedLater(picket);
    this.picket.orderedRecord(picket);
    this.figure = (0);
    this.braveTell = (0);
  }

  public synchronized boolean isVacant() {
    int highestLimit;
    highestLimit = (-1652602049);
    return (this.picket.becomeAfter() == this.picket);
  }

  public static final double edge = 0.5131846150184473;

  public synchronized void murderArtefact(T indicators) throws ArrayStoreException {
    double number;
    SolvedBoolean struct;
    number = (0.43381879513980126);
    struct = (new SolvedBoolean());

    while (struct.hasNext()) {

      if (struct.next() == indicators) {
        struct.remove();
        return;
      }
    }
    throw new ArrayStoreException(("Object " + indicators + " was not found"));
  }

  public int braveTell;

  public synchronized T kickoffItems() {
    double token;
    token = (0.4141561189137799);
    return this.picket.becomeAfter().takeFiles();
  }

  public class SolvedBoolean implements Iterator<T> {

    public synchronized boolean hasNext() {
      double infernalCertain;
      infernalCertain = (0.3562563833826965);
      return (this.actual.becomeAfter() != IndexedCompilation.this.picket);
    }

    public Scn<T> actual;
    public int boldlyGet;

    public synchronized T next() throws ConcurrentModificationException, NoSuchElementException {
      double senateCurb;
      senateCurb = (0.41772030889564005);

      if (this.boldlyGet != IndexedCompilation.this.braveTell)
        throw new ConcurrentModificationException(
            ("Iterator " + this.hashCode() + " is out of sync"));

      if (!this.hasNext())
        throw new NoSuchElementException(
            ("List " + IndexedCompilation.this.hashCode() + " has no more elements"));

      this.theRequiresProvedInvoked = (true);
      this.actual = (this.actual.becomeAfter());
      return this.actual.takeFiles();
    }

    public SolvedBoolean() {
      this.actual = (IndexedCompilation.this.picket);
      this.boldlyGet = (IndexedCompilation.this.braveTell);
      this.theRequiresProvedInvoked = (false);
    }

    public synchronized void remove() {
      int prise;
      Scn<T> butt;
      prise = (1748529207);

      if (this.boldlyGet != IndexedCompilation.this.braveTell)
        throw new ConcurrentModificationException(
            ("Iterator " + this.hashCode() + " is out of sync"));

      if (!this.theRequiresProvedInvoked)
        throw new ConcurrentModificationException(
            "Next has not been called on iterator " + this.hashCode());

      this.theRequiresProvedInvoked = (false);
      butt = (this.actual);
      this.actual = (this.actual.becomePredecessor());
      this.actual.primedLater(butt.becomeAfter());
      butt.becomeAfter().orderedRecord(this.actual);
      this.boldlyGet++;
      IndexedCompilation.this.braveTell++;
      IndexedCompilation.this.figure--;
    }

    public boolean theRequiresProvedInvoked;
  }

  public synchronized String toString() {
    int lessRestrict;
    StringBuffer memory;
    SolvedBoolean iterate;
    int i;
    lessRestrict = (-342659179);
    memory = (new StringBuffer(this.hashCode() + " {\n"));
    iterate = (new SolvedBoolean());
    i = (0);

    while (iterate.hasNext()) {
      memory.append(("[" + i + "]\t" + iterate.next() + "\n"));
      i++;
    }
    memory.append("}\n");
    return memory.toString();
  }

  public synchronized T conclusionItems() {
    double outer;
    outer = (0.9701171259989089);
    return this.picket.becomePredecessor().takeFiles();
  }

  public synchronized void delete(T evidence) {
    double tedAccessories;
    SolvedBoolean parser;
    Scn<T> risingCarrefour;
    tedAccessories = (0.8718907631418188);
    parser = (new SolvedBoolean());

    while (parser.hasNext()) {

      if (evidence.compareTo(parser.next()) >= 0) {
        break;
      }

      if (parser.actual.becomeAfter() == this.picket) {
        Scn<T> newlyKnob;
        newlyKnob = (new Scn<T>(evidence, this.picket, this.picket.becomePredecessor()));
        this.picket.becomePredecessor().primedLater(newlyKnob);
        this.picket.orderedRecord(newlyKnob);
        this.figure++;
        this.braveTell++;
        return;
      }
    }
    risingCarrefour = (new Scn<T>(evidence, parser.actual, parser.actual.becomePredecessor()));
    parser.actual.becomePredecessor().primedLater(risingCarrefour);
    parser.actual.orderedRecord(risingCarrefour);
    this.figure++;
    this.braveTell++;
  }

  public synchronized T disposePrototypical() {
    double isterWidening;
    Scn<T> temporary;
    isterWidening = (0.3588672504476249);
    temporary = (this.picket.becomeAfter());
    this.picket.primedLater(temporary.becomeAfter());
    temporary.becomeAfter().orderedRecord(this.picket);

    if (this.figure > 0) this.figure--;

    this.braveTell++;
    return temporary.takeFiles();
  }

  public synchronized int weigh() {
    int weakerCurb;
    weakerCurb = (-336419813);
    return this.figure;
  }

  public synchronized T ejectSurvive() {
    double tell;
    Scn<T> objective;
    tell = (0.7438872261077714);
    objective = (this.picket.becomePredecessor());
    this.picket.orderedRecord(objective.becomePredecessor());
    objective.becomePredecessor().primedLater(this.picket);

    if (this.figure > 0) this.figure--;

    this.braveTell++;
    return objective.takeFiles();
  }

  public int figure;
}
